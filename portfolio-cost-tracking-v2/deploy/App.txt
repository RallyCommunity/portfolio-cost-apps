<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Cost Tracking (v2)</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Mon Jun 13 2016 12:36:21 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Jun 13 2016 12:36:21 GMT-0600 (MDT)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 261053225508;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
(function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('CArABU.technicalservices.RollupItem',{

    _rollupDataPreliminaryBudget: undefined,
    _rollupDataTotalCost: undefined,
    _rollupDataActualCost: undefined,
    _rollupDataRemainingCost: undefined,
    _rollupDataToolTip: null,
    _notEstimated: true,
    children: undefined,

    projectCosts: undefined,
    useBudgetCalc: false,

    constructor: function(record) {
        this._rollupDataTotalCost = 0;
        this._rollupDataActualCost = 0;

        this.parent = record.get('Parent') && record.get('Parent').ObjectID || null;
        this.objectID = record.get('ObjectID');

        this._rollupDataPreliminaryBudget = this._calculatePreliminaryBudget(record.getData());
        this._rollupDataTotalCost = this.getPreliminaryBudget() || 0;
        this._rollupDataToolTip = this.getTooltip();
        this._rollupDataRemainingCost = this.getRemainingCostRollup();


        Ext.apply(this, record.getData());
    },
    addChild: function(objectID){
        if (!this.children){
            this.children = [];
        }
        this.children.push(objectID);
    },
    getExportRow: function(columns, ancestors){
        var rec = Ext.clone(ancestors);

        rec[this._type] = this.FormattedID;

        rec.type = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getTypePathDisplayName(this._type);
        _.each(columns, function(c){
            var field = c.costField || c.dataIndex || null;
            if (field){
                var data = this[field];
                if (Ext.isObject(data)){
                    rec[field] = data._refObjectName;
                } else if (Ext.isDate(data)){
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                } else {
                    rec[field] = data;
                }
            }
        }, this);
        return rec;
    },
    _calculatePreliminaryBudget: function(data){
        var preliminaryBudgetField = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.preliminaryBudgetField;
        if (data && data[preliminaryBudgetField]){
            //We need to do this in case we are using hte PreliminaryEstimate field, which is an object
            var val = data[preliminaryBudgetField].Value || data[preliminaryBudgetField];
            var cpu = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref);
            return cpu * val;
        }
        return null;
    },
    getTooltip: function(){

        var completed  = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.notAvailableText;
        if ((this.__actualUnits >= 0) && (this.__totalUnits >=0 )){
            completed = Ext.String.format("{0}/{1}", this.__actualUnits, this.__totalUnits);
        }

        var calc_type_name = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getCalculationTypeDisplayName();

        var html = Ext.String.format('{0} completed {1}<br/>', calc_type_name, completed);
        if (this.projectCosts){
            html += '<br/>Cost per unit:<br/>';
            _.each(this.projectCosts, function(project_cost, project_name){
                html += Ext.String.format('{0} {1}<br/>', Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.formatCost(project_cost), project_name);
            });
        }


        if (this._notEstimated){
            html += '<br/><p>Portfolio Item has missing ' + calc_type_name + '.  Preliminary Budget is being used to calculate Projected and Remaining costs.</p>';
        }
        return html;
    },
    getTotalCostRollup: function(){
        if (this._notEstimated){
            return this.getActualCostRollup() + this.getRemainingCostRollup();
        }
        return this._rollupDataTotalCost;
    },
    getActualCostRollup: function(){
        return this._rollupDataActualCost;
    },
    getRemainingCostRollup: function(){
        if (this._notEstimated){
            return Math.max(this.getPreliminaryBudget() || 0 - this.getActualCostRollup(), 0);
        }
        return this._rollupDataRemainingCost;
    },
    getPreliminaryBudget: function(){
        return this._rollupDataPreliminaryBudget;
    }
});
})();
Ext.define('CArABU.technicalservices.LowestLevelPortfolioRollupItem',{
    extend: 'CArABU.technicalservices.RollupItem',

    processChildren: function(){

        this._rollupDataToolTip = this.getTooltip();

        if (this._notEstimated && this.getPreliminaryBudget() > this.getActualCostRollup()){
            this._rollupDataRemainingCost = this.getPreliminaryBudget() - this.getActualCostRollup();
            this._rollupDataTotalCost = this._rollupDataActualCost + this._rollupDataRemainingCost;
        } else {
            this._rollupDataRemainingCost = this._rollupDataTotalCost  - this._rollupDataActualCost;
        }
    },
    addChild: function(child){
        if (!this.children){
            this.children = [];
            this._rollupDataTotalCost = 0; //Need to clear this out becuase this is preliminary budget if there are no children
            this._rollupDataActualCost = 0;
            this._rollupDataRemainingCost = 0;
            this.__totalUnits = 0;
            this.__actualUnits = 0;

        }
        this.children.push(child);

        this.__totalUnits += child.__totalUnits || 0;
        this.__actualUnits += child.__actualUnits || 0;

        this._notEstimated = (this.__totalUnits === 0);

        this._rollupDataActualCost += child._rollupDataActualCost;
        this._rollupDataTotalCost += child._rollupDataTotalCost;
        this._rollupDataRemainingCost = this._rollupDataTotalCost  - this._rollupDataActualCost;

        if (!this.projectCosts || !this.projectCosts[child.Project._ref]){
            this.projectCosts = this._updateProjectNameAndCostHash(this.projectCosts, child.Project);
        }
    },
    _updateProjectNameAndCostHash: function(projectCosts, project){

        projectCosts = projectCosts || {};

        var name = project._refObjectName,
            cost = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getCostPerUnit(project._ref);

        if (Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.isProjectUsingNormalizedCost(project._ref)){
            name =  "normalized (default)";
        }
        projectCosts[name] = cost;
        return projectCosts;
    }
});
Ext.define('CArABU.technicalservices.UpperLevelPortfolioRollupItem',{
    extend: 'CArABU.technicalservices.RollupItem',


    processChildren: function(){

        if (this.children && this.children.length > 0){
            var rollupDataTotal = 0,
                rollupDataActual = 0,
                rollupDataRemaining = 0,
                totalUnitsSum = 0,
                actualUnitsSum = 0,
                projectCosts = {},
                rollupItems = this.children || [],
                notEstimated = true;


            for (var i=0; i<rollupItems.length; i++){
                var item = rollupItems[i];
                item.processChildren();

                rollupDataTotal += item.getTotalCostRollup() ;
                rollupDataActual +=  item.getActualCostRollup();
                rollupDataRemaining += item.getRemainingCostRollup();
                totalUnitsSum += item.__totalUnits || 0;
                actualUnitsSum += item.__actualUnits || 0;
                projectCosts = Ext.merge(projectCosts, item.projectCosts || {});
                notEstimated = notEstimated && item._notEstimated;
            }

            this._notEstimated = notEstimated;
            this._rollupDataTotalCost = rollupDataTotal;
            this._rollupDataActualCost = rollupDataActual;
            this._rollupDataRemainingCost = rollupDataRemaining;
            this.projectCosts = projectCosts;
            this.__totalUnits = totalUnitsSum;
            this.__actualUnits = actualUnitsSum;
            this._rollupDataToolTip = this.getTooltip();
        }
    }
});

Ext.define('CArABU.technicalservices.UserStoryRollupItem', {
    extend: 'CArABU.technicalservices.RollupItem',
    constructor: function(record, totalFn, actualFn) {

        var data = record.data;
        if (record.getData && record.getData()){
            data = record.getData();
        }

        if (data){
            this.__totalUnits = totalFn(data);
            this.__actualUnits = actualFn(data);
            this._notEstimated = false;
            var costPerUnit = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref);

            this._rollupDataTotalCost = (this.__totalUnits * costPerUnit) || 0;
            this._rollupDataActualCost = (this.__actualUnits * costPerUnit) || 0;
            this._rollupDataRemainingCost = this._rollupDataTotalCost - this._rollupDataActualCost;

            this.parent = record.get('PortfolioItem') && record.get('PortfolioItem').ObjectID || null;
            this.objectID = data.ObjectID;

            this._rollupDataPreliminaryBudget = null;
            this._rollupDataToolTip = null;

            Ext.apply(this, data);
        }
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CArABU.technicalservices.CostPerProjectSettings',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.costperprojectsettings',
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){

        this.callParent();
        this.addEvents('ready');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: Ext.identityFn('Project'),
            fetch: ['Name'],
            context: {
                project: null
            },
            limit: 'Infinity'
        });
        store.load({
            scope: this,
            callback: this._buildProjectGrid
        });
    },

    _buildProjectGrid: function(records, operation, success){

        var decodedValue = {};
        if (this.initialConfig && this.initialConfig.value && !_.isEmpty(this.initialConfig.value)){
            if (!Ext.isObject(this.initialConfig.value)){
                decodedValue = Ext.JSON.decode(this.initialConfig.value);
            } else {
                decodedValue = this.initialConfig.value;
            }
        }

        var data = [],
            empty_text = "No exceptions";

        if (success) {
            _.each(records, function(project){
                var cost = decodedValue[project.get('_ref')] || null;
                if (cost){
                    data.push({projectRef: project.get('_ref'), projectName: project.get('Name'), cost: cost});
                }
            });
        } else {
            empty_text = "Error(s) fetching Project data: <br/>" + operation.error.errors.join('<br/>');
        }

        var custom_store = Ext.create('Ext.data.Store', {
            fields: ['projectRef', 'projectName', 'cost'],
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
            // showRowActionsColumn: false,
            showPagingToolbar: false,
            store: custom_store,
            maxHeight: 300,
            margin: '20 0 0 0',
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        var width = Math.max(this.inputEl.getWidth(true),300);

        Ext.create('Rally.ui.Button',{
            text: 'Select Projects',
            renderTo: this.inputEl,
            margin: '10 0 0 0',
            listeners: {
                scope: this,
                click: function(){

                    Ext.create('Rally.apps.portfolioitemcosttracking.ProjectPickerDialog',{
                        autoShow: true,
                        maxHeight: 400,
                        maxWidth: 400,
                        width: Math.min(width, 400),
                        title: 'Choose Project',
                        selectedRefs: _.pluck(data, 'projectRef'),
                        listeners: {
                            scope: this,
                            itemschosen: function(items){
                                var new_data = [],
                                    store = this._grid.getStore();

                                _.each(items, function(item){
                                    if (!store.findRecord('projectRef',item.get('_ref'))){
                                        new_data.push({
                                            projectRef: item.get('_ref'),
                                            projectName: item.get('Name'),
                                            cost: null
                                        });
                                    }
                                });
                                this._grid.getStore().add(new_data);
                            }
                        }
                    });
                }
            }
        });

        this.fireEvent('ready', true);
    },
    _removeProject: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            scope: this,
            rowActionsFn: function(record){
                return  [
                    {text: 'Remove', record: record, handler: me._removeProject, grid: me._grid }
                ];
            },
            //Need to override this since we are using a custom store
            _renderGearIcon: function(value, metaData, record) {
                return '<div class="row-action-icon icon-gear"/>';
            }
        },{
            text: 'Project',
            dataIndex: 'projectRef',
            flex: 1,
            editor: false,
            renderer: function(v, m, r){
                return r.get('projectName');
            },
            getSortParam: function(v,m,r){
                return 'projectName';
            }
        },{
            text: 'Cost Per Unit',
            dataIndex: 'cost',
            editor: {
                xtype: 'rallynumberfield'
            },
            renderer: function(v){
                if (v && v > 0){
                    return v;
                }
                return "Use Default";
            }
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {};
        var store = this._grid.getStore();

        store.each(function(record) {
            if (record.get('cost') && record.get('projectRef')) {
                mappings[record.get('projectRef')] = record.get('cost');
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});



Ext.define('CArABU.technicalservices.CostTemplateColumn', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.costtemplatecolumn'],

    align: 'right',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}" style="cursor:pointer;text-align:right;">{[this.getCost(values)]}</div></tpl>',{
            costField: me.costField,

            getCost: function(values){
                if (values[this.costField] === null){
                    return Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.notAvailableText;
                } else {
                    var html = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.formatCost(values[this.costField] || 0);
                    if (values._notEstimated && this.costField === '_rollupDataTotalCost'){
                        html = '<span class="picto icon-warning warning" style="color:#FAD200;font-size:10px;"></span>' + html;
                    }
                    return html;
                }
            },
            getTooltip: function(values){
                if (values._rollupDataToolTip){
                    return values._rollupDataToolTip;
                }
                return '';
            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    getValue: function(){
        return values[this.costField] || 0;
    },
    defaultRenderer: function(value, meta, record) {
        var data = Ext.apply({}, record.data._rollupData); //, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});

Ext.define('CArABU.technicalservices.Exporter',{

    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
    },
    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },
    saveAs: function(textToWrite, fileName)
    {
        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    fetchExportData: function(rootModel, rootFilters, fetch, columns){
        var deferred = Ext.create('Deft.Deferred');
        var rootFetch = Ext.Array.merge(fetch, Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getPortfolioItemFetch());
        var me = this;


        var loader = Ext.create('Rally.apps.portfolioitemcosttracking.RollupDataLoader',{
            portfolioItemTypes: Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(),
            featureName: Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getFeatureName(),
            listeners: {
                rollupdataloaded: function(portfolioHash, stories){
                    //onsole.log('rollupdataloaded', portfolioHash, stories);
                    var rollupData = Ext.create('Rally.apps.portfolioitemcosttracking.RollupCalculator', {
                        portfolioItemType: rootModel
                    });

                    rollupData.addRollupRecords(portfolioHash, stories);
                    //onsole.log('models updateded', portfolioHash, stories);
                    var exportData = me._getExportableRollupData(portfolioHash[rootModel.toLowerCase()],columns, rollupData);
                    columns = me._getAncestorTypeColumns(rootModel).concat(columns);

                    var csv = me._transformExportableRollupDataToDelimitedString(exportData, columns);
                    this.fireEvent('statusupdate', null);
                    deferred.resolve(csv);
                },
                loaderror: function(msg){
                    deferred.reject(msg);
                },
                statusupdate: function(status){
                    this.fireEvent('statusupdate', status);
                },
                scope: this
            }
        });
        loader.loadTree({model: rootModel, fetch: rootFetch, filters: rootFilters || []});

        return deferred;
    },
    _transformExportableRollupDataToDelimitedString: function(rollupData, columns){
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n','g');

        var column_keys = _.map(columns, function(c){ return c.costField || c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(rollupData, function(obj){
            var data = [];
            Ext.Array.each(column_keys, function(key){
                var val = obj[key];
                if (val){
                    if (re.test(val)){ //enclose in double quotes if we have the delimiters
                        val = val.replace('"','\"\"');
                        val = Ext.String.format("\"{0}\"",val);
                    }
                }
                data.push(val);
            });
            csvArray.push(data.join(delimiter));
        });

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableRollupData: function(records, columns, rollupData){

        var exportData = [],
            me = this;


        _.each(records, function(r){
            var obj = rollupData.getRollupData(r);
            if (obj){
                var ancestors = {};
                var rec = obj.getExportRow(columns, ancestors);
                exportData.push(rec);
                me._addExportChildren(obj,exportData, columns, rollupData,ancestors);
            }
        }, this);
        return exportData;
    },
    _addExportChildren: function(obj, exportData, columns, rollupData,ancestors){
        var new_ancestors = Ext.clone(ancestors),
            me = this;
        new_ancestors[obj._type] = obj.FormattedID;

        var children = obj.children;
        if (children && children.length > 0){
            _.each(children, function(c){
                var row = c.getExportRow(columns, new_ancestors);
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, rollupData, new_ancestors);
            }, this);
        }
        return;
    },
    _getAncestorTypeColumns: function(rootModel){
        var piTypes = Rally.apps.portfolioitemcosttracking.PortfolioItemCostTrackingSettings.getPortfolioItemTypeObjects(),
            piIdx = -1;

        Ext.Array.each(piTypes, function(piObj, idx){
            if (piObj.typePath.toLowerCase() === rootModel.toLowerCase()){
                piIdx = idx;
            }
        });

        var columns = [{
            dataIndex: 'hierarchicalrequirement',
            text: 'User Story'
        }];

        if (piIdx >= 0){
            columns = columns.concat(Ext.Array.map(piTypes.slice(0,piIdx+1), function(piObj) { return { dataIndex: piObj.typePath.toLowerCase(), text: piObj.name };} ));
            columns.push({
                dataIndex: 'type',
                text: 'Artifact Type'
            });
            columns.reverse();
        }
        return columns;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    }
});


/**
 * Created this to allow for any custom fields to be used as the Preliminary Budget field
 * Requirements changed to only allow Preliminary Budget and Refined Estimate.
 */

Ext.define('CArABU.technicalservices.NumberFieldComboBox', {
    requires: [],
    extend: 'Rally.ui.combobox.FieldComboBox',
    alias: 'widget.numberfieldcombobox',
    _isNotHidden: function(field) {
        var validFields= ['PreliminaryEstimate','RefinedEstimate'],
            allowCustomNumberFields = false;

        if (!field.hidden) {

            if (Ext.Array.contains(validFields, field.name)) {
                return true;
            }

            //Allow for custom number fields
            if (allowCustomNumberFields && field.custom && field.attributeDefinition) {
                return (field.attributeDefinition.AttributeType === "INTEGER" ||
                field.attributeDefinition.AttributeType === "DECIMAL");
            }
        }
        return false;
    }
});


Ext.override(Rally.ui.grid.TreeGrid, {
    _mergeColumnConfigs: function(newColumns, oldColumns) {

        var mergedColumns= _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, {dataIndex: this._getColumnName(newColumn)});
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);

        mergedColumns = mergedColumns.concat(this.config.derivedColumns);
        return mergedColumns;
    },
    _getPersistableColumnConfig: function(column) {

        var columnConfig = this._getColumnConfigFromColumn(column),
            field = this._getModelField(columnConfig.dataIndex);

        if (field && field.getUUID && field.getUUID()) {
            columnConfig.dataIndex = field.getUUID();
        }
        return columnConfig;
    }
});

Ext.define('CArABU.technicalservices.promise.ParallelThrottle',{
    requires: ['Deft.promise.Promise'],
    statics: {

        throttle: function (fns, maxParallelCalls, scope) {

            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }


            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        }
    }
});


Ext.define('TreeGridContainerCustomFilterControl', {
    alias: 'plugin.treegridcontainercustomfiltercontrol',
    extend:'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',

    showControl: function() {
        if (!this.controlCmp) {
            this._createControlCmp();
        }

        if (this.controlCmp) {
            this.controlCmp.show();
        }

        return this.controlCmp;
    }
});

Ext.define('TreeGridContainerFieldPicker', {
    alias: 'plugin.treegridcontainerfieldpicker',
    extend:'Ext.AbstractPlugin',
    mixins: ['Rally.ui.gridboard.plugin.GridBoardControlShowable'],
    requires: [
        'Rally.ui.popover.Popover',
        'Rally.ui.Button',
        'Rally.ui.picker.FieldPicker'
    ],

    /**
     * @cfg {String[]} alwaysSelectedFields
     * The fields that will be always selected in the field picker for the grid view
     */
    gridAlwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

    /**
     * @cfg {String[]} gridFieldBlackList
     * The fields that will be blacklisted in grid mode
     */
    gridFieldBlackList: [
        'Actuals',
        'Changesets',
        'Children',
        'Description',
        'Notes',
        'ObjectID',
        'Predecessors',
        'RevisionHistory',
        'Subscription',
        'Successors',
        'TaskIndex',
        'Workspace',
        'VersionId'
    ],

    /**
     * @cfg {String[]}
     * the names of the models displayed on the board.
     */
    modelNames: [],

    stateful: true,

    margin: '3 9 10 10',

    constructor: function (config) {
        config.gridFieldBlackList = _.union(this.gridFieldBlackList, config.gridFieldBlackList);
        config.gridAlwaysSelectedValues = _.union(this.gridAlwaysSelectedValues, config.gridAlwaysSelectedValues);
        this.callParent(arguments);
    },

    init: function(cmp) {
        this.callParent(arguments);
        this.cmp = cmp;

        var rankingEnabled = this.cmp.getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled && cmp.gridConfig.enableRanking !== false;

        this.gridAlwaysSelectedValues = this._modifyFieldCollection(this.gridAlwaysSelectedValues, ['DragAndDropRank'], rankingEnabled);
        this.gridFieldBlackList = this._modifyFieldCollection(this.gridFieldBlackList, ['DragAndDropRank'], !rankingEnabled);
        this.stateId = this.stateId || this.cmp.getFieldListStateId();

        var state = Ext.state.Manager.get(this.stateId);
        this._fields = state && state.fields;

        this.showControl();
    },
    showControl: function() {
        if (!this.controlCmp) {
            this._createControlCmp();
        }

        if (this.controlCmp) {
            this.controlCmp.show();
        }

        return this.controlCmp;
    },
    _modifyFieldCollection: function (collection, fields, include) {
        if (include) {
            return _.union(collection, fields);
        }
        return _.reject(collection, function (field) { return _.contains(fields, field); });
    },

    getControlCmpConfig: function() {
        return {
            xtype: "rallybutton",
            itemId: 'fieldpickerbtn',
            cls: 'field-picker-btn secondary rly-small',
            margin: this.margin,
            iconCls: 'icon-add-column',
            toolTipConfig: {
                html: this.getTitle(),
                anchor: 'top'
            },
            listeners: {
                click: this._onClick,
                scope: this
            }
        };
    },

    _onClick: function(btn) {
        this._createPopover(btn.getEl());
    },

    _getPickerConfig: function() {
        var pickerConfig;

        pickerConfig = _.extend({
            value: _.pluck(this.cmp.getGrid().columns, 'dataIndex').join(','),
            fieldBlackList: this.gridFieldBlackList,
            alwaysSelectedValues: this.gridAlwaysSelectedValues
        }, this.fieldPickerConfig);

        return pickerConfig;
    },

    _createPopover: function(popoverTarget) {
        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: popoverTarget,
            placement: ['bottom', 'left', 'top', 'right'],
            cls: 'field-picker-popover',
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: this.getTitle(),
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Apply',
                    cls: 'field-picker-apply-btn primary rly-small',
                    listeners: {
                        click: function() {
                            this._onApply(this.popover);
                        },
                        scope: this
                    }
                },
                {
                    xtype: "rallybutton",
                    text: 'Cancel',
                    cls: 'field-picker-cancel-btn secondary dark rly-small',
                    listeners: {
                        click: function() {
                            this.popover.close();
                        },
                        scope: this
                    }
                }
            ],
            items: [
                _.extend({
                    xtype: 'rallyfieldpicker',
                    cls: 'field-picker',
                    itemId: 'fieldpicker',
                    modelTypes: this._getModelTypes(),
                    alwaysExpanded: true,
                    width: 200,
                    placeholderText: 'Search',
                    selectedTextLabel: 'Selected',
                    availableTextLabel: 'Available',
                    listeners: {
                        specialkey: function(field, e) {
                            if (e.getKey() === e.ESC) {
                                this.popover.close();
                            }
                        },
                        scope: this
                    }
                }, this._getPickerConfig())
            ]
        });
    },

    _getModelTypes: function() {
        return _.pluck(this._getModels(), 'typePath');
    },

    _getModels: function() {
        return _.reduce(this.cmp.getModels(), function(accum, model) {
            if (model.typePath === 'artifact') {
                accum = accum.concat(model.getArtifactComponentModels());
            } else {
                accum.push(model);
            }
            return accum;
        }, []);
    },


    getTitle: function () {
        return 'Show Columns';
    },

    /**
     * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
     * the fields on the cards
     *
     * @param {String[]|Object[]} fields A list of field names to display
     * @param {Boolean} true to suspend store load if it will be triggered elsewhere
     */
    updateFields: function (fields, suspendLoad) {
        this._fields = _.map(fields, function (field) {
            return field.get('name');
        });

        this.cmp.updateFields(this._fields, false, suspendLoad);

        this._updatePickerValue(this._fields);

    },

    _updatePickerValue: function(fields) {
        if (this.popover && this.popover.down('rallyfieldpicker')) {
            this.popover.down('rallyfieldpicker').setValue(this._fields.join(','));
        }
    },

    _onApply: function(popover) {
        var fieldPicker = popover.down('rallyfieldpicker');

        this.updateFields(fieldPicker.getValue());

        popover.close();
    }
});



Ext.define('CArABU.technicalservices.ProjectPickerDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.projectpickerdialog',


    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemschosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemschosen', this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },
    getStoreFilters: function() {
        return [];
    },
    _buildTreeStore: function(){
        return Ext.create('Rally.data.wsapi.ProjectTreeStoreBuilder').build({
            models: ['project'],
            autoLoad: true,
            enableHierarchy: true,
            filters: [{
                property: 'Parent',
                value: ""
            }]
        });
    },
    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }

        this._buildTreeStore().then({
            success: function(store){
                var mode = this.multiple ? 'MULTI' : 'SINGLE';

                var checkbox_model = Ext.create('Rally.ui.selection.CheckboxModel', {
                    mode: mode,
                    enableKeyNav: false,
                    allowDeselect: true
                });

                this.grid = this.add({
                    xtype: 'rallytreegrid',
                    treeColumnDataIndex: 'Name',
                    treeColumnHeader: 'Name',
                    viewConfig: {
                        cls: 'grid-view-bulk-edit'
                    },
                    enableRanking: false,
                    enableEditing: false,
                    enableBulkEdit: false,
                    shouldShowRowActionsColumn: false,
                    showRowActionsColumn: false,
                    selModel: checkbox_model,
                    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                        store = store.treeStore || store;
                        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('Name')).apply(record.data);
                    },
                    columnCfgs: [],
                    store: store
                });

                this.mon(this.grid, {
                    beforeselect: this._onGridSelect,
                    beforedeselect: this._onGridDeselect,
                    load: this._onGridLoad,
                    scope: this
                });
                this.add(this.grid);
                this._onGridReady();
            },
            failure: function(msg){},
            scope: this
        });

    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);

        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }
        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },
    _onGridLoad: function() {
        var store = this.grid.store;
        var records = [];
        _.each(this.selectionCache, function(record) {
            var foundNode = store.getRootNode().findChild('_ref', record.get('_ref'),true);

            if (foundNode) {
                records.push(foundNode);
            }
        });
        if (records.length) {
            this.grid.getSelectionModel().select(records);
        }
    },
    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        //Filter functions call store load so we don't need to refresh the selections becuaes the
        //onGridLoad function will
        if (terms) {
            store.filter([
                Ext.create('Rally.data.wsapi.Filter',{
                    property: 'Name',
                    operator: 'contains',
                    value: terms
                })
            ]);
        } else {
            store.clearFilter();
        }

    },
    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

Ext.override(Rally.data.wsapi.ParentChildMapper, {
    constructor: function() {
        this.parentChildTypeMap = {
            project: [{
                typePath: 'project', collectionName: 'Children', parentField: 'Parent'
            }],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    }
});


Ext.define('Rally.data.wsapi.ProjectTreeStore', {

    // Client Metrics Note: WsapiTreeStore is too low level to record its load begins/ends. The problem is
    // client metrics can only reliably keep track of one load per component at a time. WsapiTreeStore makes
    // no guarantee that only one load will happen at a time. It's better to measure the component that is using
    // the store. All is not lost, the actual data requests that WsapiTreeStore makes *are* measured by client metrics.

    requires: [
        'Deft.promise.Deferred',
        'Rally.data.ModelFactory',
        'Rally.ui.grid.data.NodeInterface',
        'Rally.data.ModelTypes',
        'Rally.data.wsapi.ParentChildMapper'
    ],
    extend: 'Rally.data.wsapi.TreeStore',
    alias: 'store.rallyprojectwsapitreestore',

    /**
     * The type definition typePaths to render as root items (required)
     * @cfg {String[]} parentTypes
     */
    parentTypes: ['project'],

    /**
     * @property
     * @private
     */
    childLevelSorters: [{
        property: 'Name',
        direction: 'ASC'
    }],

    getParentFieldNamesByChildType: function(childType, parentType) {
        var model = this.model; //.getArtifactComponentModel(childType);
        return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
            var fieldName = field.fieldName,
                hasFieldModel = model.hasField(fieldName);

            if (hasFieldModel) {
                acc.push(fieldName.replace(/\s+/g, ''));
            }
        }, [], this);
    },

    filter: function(filters) {
        this.fireEvent('beforefilter', this);
        //We need to clear the filters to remove the Parent filter
        this.filters.clear();
        this.filters.addAll(filters);
        this._resetCurrentPage();
        this.load();
    },

    clearFilter: function(suppressEvent) {
        this._resetCurrentPage();
        this.filters.clear();
        //We need to add the parent filter back in
        this.filters.addAll(Ext.create('Rally.data.wsapi.Filter',{
            property: 'Parent',
            value: ''
        }));

        if (!suppressEvent) {
            this.load();
        }
    },

    load: function(options) {
        this.recordLoadBegin({description: 'tree store load', component: this.requester});

        this._hasErrors = false;

        this.on('beforeload', function(store, operation) {
            delete operation.id;
        }, this, { single: true });

        options = this._configureLoad(options);
        options.originalCallback = options.callback;
        var deferred = Ext.create('Deft.Deferred'),
            me = this;

        options.callback = function (records, operation, success) {
            me.dataLoaded = true;

            if(me.isRootNode(options.node) && operation.resultSet && operation.resultSet.sums) {
                me.setSums(operation.resultSet.sums);
            }

            if (me._pageIsEmpty(operation)) {
                me._reloadEmptyPage(options).then({
                    success: function (records) {
                        me._resolveLoadingRecords(deferred, records, options, operation, success);
                    },
                    failure: function() {
                        me._rejectLoadingRecord(deferred, options, operation);
                    }
                });
            } else {
                me._resolveLoadingRecords(deferred, records, options, operation, success);
            }
        };

        if (this._isViewReady()) {
            this._beforeInitialLoad(options);
        }

        this.callParent([options]);

        return deferred.promise;
    }

});

Ext.define('Rally.data.wsapi.ProjectTreeStoreBuilder', {
    extend: 'Rally.data.wsapi.TreeStoreBuilder',

    build: function(config) {
        //A context needs to be passed in here, and it NEEDS to be a DataContext (context.getDataContext())
        //otherwise you will get a bunch of garbage on your WSAPI request

        config = _.clone(config || {});
        config.storeType = 'Rally.data.wsapi.ProjectTreeStore';

        return this.loadModels(config).then({
            success: function(models) {
                models = _.values(models);
                return this._buildStoreWithModels(models, config);
            },
            scope: this
        });
    }
});
(function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('CArABU.technicalservices.RollupCalculator', {
        extend: 'Ext.Base',



        mixins: {
            observable: 'Ext.util.Observable'
        },

        rollupItems: undefined,

        constructor: function (config) {
            this.mixins.observable.constructor.call(this, config);
            this.rollupItems = {};
            this.portfolioItemType = config.portfolioItemType;
        },
        addRollupRecords: function(portfolioItemRecordHash, stories){
            var portfolioItemTypes = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes();

            this.rootObjectIDs = [];
            for (var i=portfolioItemTypes.length -1; i >= 0; i--){
                var portfolioRecords = portfolioItemRecordHash[portfolioItemTypes[i]] || [];
                this._addPortfolioRecords(portfolioRecords);
            }

            this._addStories(stories);
            this._calculatePortfolioItemRollups();

        },
        getRollupData: function(record){
            if (!record){
                return null;
            }
            var objectID = record.ObjectID || record.get('ObjectID');
            return this.rollupItems[objectID] || null;
        },
        /**
         * Adds records needed to calculate the rollup data
         * @param records
         */
        _addPortfolioRecords: function(records){
            if (!records || records.length === 0){
                return;
            }

            var type = records[0].get('_type').toLowerCase(),
                rollupItemType = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getRollupItemType(type),
                rootPortfolioItem = this.portfolioItemType.toLowerCase();
            console.log('rollupItemType', rollupItemType);
            if (rollupItemType){ //this is a portfolio item type
                for (var i=0; i<records.length; i++){
                    var r = records[i],
                        oid = r.get('ObjectID'),
                        parentObjectID = r.get('Parent') && r.get('Parent').ObjectID,
                        item = Ext.create(rollupItemType, r);

                    this.rollupItems[oid] = item;

                    if (parentObjectID && this.rollupItems[parentObjectID]){
                        this.rollupItems[parentObjectID].addChild(item);
                    }

                    if (type === rootPortfolioItem){
                        this.rootObjectIDs.push(oid);
                    }
                }
            }
        },

        _addStories: function(stories){
            var parents = [],
            //rollupItems = this.rollupItems,
                totalFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().totalUnitsForStoryFn,
                actualFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().actualUnitsForStoryFn;

            for(var i =0; i < stories.length; i++){
                var item = Ext.create('CArABU.technicalservices.UserStoryRollupItem', stories[i], totalFn, actualFn);

                this.rollupItems[item.ObjectID] = item;

                if (item.parent && this.rollupItems[item.parent]){
                    parents.push(item.parent);
                    this.rollupItems[item.parent].addChild(item);
                }
            }
        },

        _calculatePortfolioItemRollups: function(){
            for (var i=0; i<this.rootObjectIDs.length; i++){
                var item = this.rollupItems[this.rootObjectIDs[i]];
                if (item && item._type.toLowerCase() === this.portfolioItemType.toLowerCase()){
                    item.processChildren();
                }

            }
        },
        updateModels: function(records){
            records = records || [];
            var unloadedModels = [],
                rollupItems = this.rollupItems;

            for (var i=0; i<records.length; i++){
                var r = records[i],
                    rollupItem = rollupItems[r.get('ObjectID')] || null;
                if (rollupItem){
                    r.set('_rollupData', rollupItem);
                } else {
                    unloadedModels.push(r);
                }
            }
            return unloadedModels;
        },
        destroy: function(){
            this.rollupItems = {};
        }
    });
}) ();
(function() {
    var Ext = window.Ext4 || window.Ext;

    ///**
    // * Class to load lots of data and update as status is made.
    // */
    Ext.define('CArABU.technicalservices.RollupDataLoader',{

        storyModelName: 'hierarchicalrequirement',

        mixins: {
            observable: 'Ext.util.Observable'
        },

        model: undefined,
        filters: undefined,
        fetch: undefined,

        maxParallelCalls: 6,
        maxListSize: 50,

        constructor: function (config) {
            this.mixins.observable.constructor.call(this, config);
            this.portfolioItemTypes = config.portfolioItemTypes || [];
        },
        loadTree: function(config){
            this.rootConfig = config;
            this.additionalFetch = config.fetch;
            this.load(config.model);
        },
        loadDescendants: function(rootRecords, additionalFetch){
            this.rootRecords = rootRecords;
            this.additionalFetch = additionalFetch || [];
            if (!rootRecords || rootRecords.length === 0){
                this.fireEvent('loaderror', "No root records to load descendents for.");
                return;
            }
            var model = this.getChildPortfolioItemType(rootRecords[0].get('_type'));
            this.load(model);
        },

        load: function(model){

            if (this.portfolioItemTypes.length === 0){
                this.fireEvent('loaderror', "Portfolio Item Types not initialized.");
                return;
            }

            this.storyFetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getStoryFetch(this.additionalFetch);
            this.portfolioItemFetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemFetch(this.additionalFetch);

            var idx = _.indexOf(this.portfolioItemTypes, model.toLowerCase());
            var fns = [];

            for (var i=idx; i>=0; i--){
                fns.push(this.fetchPortfolioItems);
            }
            fns.push(this.fetchUserStories);
            this.recordsHash = {};

            Deft.Chain.pipeline(fns, this).then({
                success: function(stories){
                    this.fireEvent('rollupdataloaded', this.recordsHash, _.flatten(stories));
                },
                failure: function(msg){
                    this.fireEvent('loaderror', msg);
                },
                scope: this
            });
        },
        fetchRoot: function(){
            this.fireEvent('statusupdate', "Loading artifacts");
            var config = this.rootConfig || {};
            config.fetch = config.fetch.concat(this.getRequiredFetchFields(config.model));

            return this.fetchWsapiRecordsWithPaging(config);
        },
        getChildPortfolioItemType: function(type){
            var idx = _.indexOf(this.portfolioItemTypes, type.toLowerCase());
            if (idx > 0){
                return this.portfolioItemTypes[idx-1];
            }
            return this.storyModelName;
        },
        fetchPortfolioItems: function(parentRecords){
            parentRecords = parentRecords || this.rootRecords;
            if (!parentRecords || parentRecords.length === 0){
                return this.fetchRoot();
            }
            parentRecords = _.flatten(parentRecords);

            var parentType = parentRecords[0].get('_type');
            this.recordsHash[parentType] = parentRecords;

            var type = this.getChildPortfolioItemType(parentType),
                fetch = this.portfolioItemFetch.concat(this.getRequiredFetchFields(type)),
                chunks = this._getChunks(parentRecords, 'Children', 'Count');

            return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
        },
        _getChunks: function(parentRecords, countField, countFieldAttribute){
            var chunks = [],
                childCount = 0,
                maxListSize = this.maxListSize,
            //childCountTarget = 200,
                idx = 0;

            chunks[idx] = [];
            _.each(parentRecords, function(r){
                var count = r.get(countField);
                if (countFieldAttribute && count){
                    count = count[countFieldAttribute];
                }
                if (count > 0){
                    if (chunks[idx].length >= maxListSize){ //childCount + count > childCountTarget ||
                        idx++;
                        chunks[idx] = [];
                        childCount = 0;
                    }
                    childCount += count;
                    chunks[idx].push(r.get('ObjectID'));
                }
            });
            return chunks;
        },
        fetchUserStories: function(parentRecords){
            parentRecords = parentRecords || this.rootRecords;
            if (!parentRecords || parentRecords.length === 0){
                return this.fetchRoot();
            }
            parentRecords = _.flatten(parentRecords);

            var parentType = parentRecords[0].get('_type');
            this.recordsHash[parentType] = parentRecords;

            var type = this.storyModelName,
                fetch = this.storyFetch.concat(this.getRequiredFetchFields(type)),
                chunks = this._getChunks(parentRecords, 'UserStories','Count'),
                featureParentName = this.featureName + ".ObjectID";

            return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
        },
        fetchChunks: function(type, fetch, chunks, chunkProperty, statusString){

            if (chunks && chunks.length > 0 && chunks[0].length===0){
                return Promise.resolve([]);
            }

            this.fireEvent('statusupdate', statusString);

            var promises = [];
            _.each(chunks, function(c){
                var filters = _.map(c, function(ids){ return {property: chunkProperty, value: ids }; }),
                    config = {
                        model: type,
                        fetch: fetch,
                        filters: Rally.data.wsapi.Filter.or(filters)
                    };
                promises.push(function(){ return this.fetchWsapiRecords(config); });
            });

            return this.throttle(promises, this.maxParallelCalls, this);
        },
        fetchWsapiRecords: function(config){
            var deferred = Ext.create('Deft.Deferred');

            Ext.create('Rally.data.wsapi.Store',{
                model: config.model,
                fetch: config.fetch,
                filters: config.filters,
                limit: 'Infinity'
            }).load({
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
            });
            return deferred;
        },
        getRequiredFetchFields: function(type){

            if (type.toLowerCase() === this.storyModelName){
                return ['Parent','PortfolioItem','ObjectID'];
            }
            return  ['Children', 'UserStories','Parent','ObjectID'];
        },
        throttle: function (fns, maxParallelCalls, scope) {

            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }


            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        },
        fetchWsapiCount: function(model, query_filters){
            var deferred = Ext.create('Deft.Deferred');

            Ext.create('Rally.data.wsapi.Store',{
                model: model,
                fetch: ['ObjectID'],
                filters: query_filters,
                limit: 1,
                pageSize: 1
            }).load({
                callback: function(records, operation, success){
                    if (success){
                        deferred.resolve(operation.resultSet.totalRecords);
                    } else {
                        deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                    }
                }
            });
            return deferred;
        },
        fetchWsapiRecordsWithPaging: function(config){
            var deferred = Ext.create('Deft.Deferred'),
                promises = [],
                me = this;

            this.fetchWsapiCount(config.model, config.filters).then({
                success: function(totalCount){
                    var store = Ext.create('Rally.data.wsapi.Store',{
                            model: config.model,
                            fetch: config.fetch,
                            filters: config.filters,
                            pageSize: 200
                        }),
                        totalPages = Math.ceil(totalCount/200);

                    var pages = _.range(1,totalPages+1,1);

                    this.fireEvent('statusupdate',Ext.String.format(config.statusDisplayString || "Loading {0} artifacts", totalCount));

                    _.each(pages, function(page){
                        promises.push(function () {return me.loadStorePage(page, store);});
                    });

                    this.throttle(promises, 12, me).then({
                        success: function(results){
                            deferred.resolve(_.flatten(results));
                        },
                        failure: function(msg){
                            deferred.reject(msg);
                        },
                        scope: me
                    });
                },
                failure: function(msg){
                    deferred.reject(msg);
                },
                scope: me
            });
            return deferred;
        },
        loadStorePage: function(pageNum, store){
            var deferred = Ext.create('Deft.Deferred');

            store.loadPage(pageNum, {
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('loadStorePage error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
            });

            return deferred;
        }

    });
})();
Ext.define('CArABU.technicalservices.PortfolioItemCostTrackingSettings', {
    singleton: true,

    /**
     * App Settings
     */
    selectedCalculationType: undefined,
    /**
     * Currency display settings to pass into the Ext.util.Format currency function
     */
    currencySign: '$',
    currencyPrecision: 0,
    currencyEnd: false,

    normalizedCostPerUnit: 1,
    projectCostPerUnit: {},

    preliminaryBudgetField: 'PreliminaryEstimate',
    /**
     * App configurations
     */

    tooltipActualCost: 'actualcost ',
    tooltipTotalCost: 'totalcost',
    tooltipRemainingCost: 'remaining cost',
    tooltipPreliminaryBudget: 'preliminary budget',

    calculationTypes: {
        points: {
            key: 'points',
            label: 'Based on Story Points',
            displayName: 'Story Points',
            defaultColumns: ['Name', 'Project', 'PlanEstimate', 'LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','PlanEstimate'],
            requiredTaskFetch: [],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Accepted Story Plan Estimates <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the Total Projected Cost - Actual Cost',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Plan Estimate <i>for each story in scope</i>* Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){
                if (data && data.PlanEstimate && Ext.Array.contains(CArABU.technicalservices.PortfolioItemCostTrackingSettings.completedScheduleStates, data.ScheduleState)) {
                    return data && data.PlanEstimate || 0;
                }
                return 0;
            },
            totalUnitsForStoryFn: function(data){
                return data && data.PlanEstimate || 0;
            }
        },
        taskHours: {
            key: 'taskHours',
            displayName: 'Task Actuals',
            label: 'Based on Task Actuals',
            defaultColumns: ['Name','Project'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','TaskEstimateTotal','TaskActualTotal','TaskRemainingTotal'],
            requiredTaskFetch: ['ToDo','Actuals'],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Task Actuals <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the sum of the ToDo <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Task Estimate Total <i>for each story in scope</i> * Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){ return data.TaskActualTotal || 0; },
            totalUnitsForStoryFn: function(data){
                return (data && data.TaskActualTotal || 0) + (data && data.TaskRemainingTotal || 0);
            },
            actualUnitsForTaskFn: function(data){
                return data && data.Actuals || 0;
            },
            totalUnitsForTaskFn: function(data){
                return (data && data.ToDo || 0) + (data && data.Actuals || 0);
            }
        },
        timesheets: {
            key: 'timesheets',
            displayName: 'Time Spent',
            label: 'Based on Timesheets',
            defaultColumns: ['Name','Project'],
            requiredStoryFetch: [],
            requiredTaskFetch: [],
            disabled: true,
            actualUnitsForStoryFn: function(data){ return 0; },
            actualUnitsForTaskFn: function(data){ return 0; },
            totalUnitsForStoryFn: function(data){  return 0; },
            totalUnitsForTaskFn: function(data){  return 0; }
        }
    },

    /**
     * Required fetch fields in addition to what the Tree might fetch.  We need these for the rollup data fetch lists and for group by Release
     */
    requiredPortfolioItemFetch: ['UserStories'],
    requiredFetch: ['ObjectID','FormattedID','Project','Parent','Children','Release','Name'],

    notAvailableText: '--',

    completedScheduleStates: [],

    portfolioItemTypes: [],

    currencyData: [
        {name: "US Dollars", value: "$"},
        {name: "Euro", value: "&#128;"},
        {name: "Japanese Yen", value: "&#165;"},
        {name: "Brazilian Real", value: "R$"},
        {name: "South African Rand", value: "R"}
    ],
    getFeatureName: function(){
        return this.portfolioItemTypes[0].name.replace(/\s/g, '');
    },
    getHeaderTooltip: function(field){
        var settings = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings();
        return settings.tooltips[field] || null;

    },
    setCalculationType: function(type){
        //Check that actuals is on, and warn user if it is not.
        if (type === 'taskHours'){
            Rally.data.ModelFactory.getModel({
                type: 'task',
                success: function(model){
                    var field = model.getField('Actuals');
                    if (field && field.hidden){
                        Rally.ui.notify.Notifier.showWarning({message: 'The Task Actuals field is not visible in the current project.  As a result, Task Actuals values may be 0.'});
                    }
                }
            });
        }


        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes[type]){
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType = type;
        } else {
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType = 'points';
        }
    },
    /**
     * getPortfolioItemTypeLevel
     * @param modelName
     * Given a model name, this function returns the level of portfolio item the model name is:
     *  0 = Lowest Level (Feature)
     *  1 = Second Level (e.g. Initiative)
     *  ...
     *  return -1 if the modelName is not a portfolio item type
     */
    getPortfolioItemTypeLevel: function(modelName){
        var idx = _.indexOf(CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(), modelName.toLowerCase());
        return idx;
    },
    getRollupItemType: function(type){
        var idx = _.indexOf(CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(), type.toLowerCase());
        if (idx > 0){
            return 'CArABU.technicalservices.UpperLevelPortfolioRollupItem';
        }
        if (idx === 0){
            return 'CArABU.technicalservices.LowestLevelPortfolioRollupItem';
        }
        return null;
    },
    getPortfolioItemTypes: function(){
        return _.map( this.portfolioItemTypes, function(p){ return p.typePath.toLowerCase(); });
    },
    getPortfolioItemTypeObjects: function(){
        return this.portfolioItemTypes;
    },
    getTypePathDisplayName: function(piTypePath){
        if (piTypePath.toLowerCase() === 'hierarchicalrequirement'){
            return 'User Story';
        }

        var piDisplayName = '';

        Ext.Array.each(this.portfolioItemTypes, function(p){
            if (p.typePath.toLowerCase() === piTypePath.toLowerCase()){
                piDisplayName = p.name;
                return false;
            }
        });
        return piDisplayName;
    },
    getCalculationTypeSettings: function(){
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes[CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType] || CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes.points;
    },
    getCalculationTypeDisplayName: function(){
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().displayName || 'Unknown';
    },
    formatCost: function(cost){
        return Ext.util.Format.currency(cost,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencySign,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyPrecision,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyEnd);
    },
    getCostPerUnit: function(project_ref){
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit[project_ref] || CArABU.technicalservices.PortfolioItemCostTrackingSettings.normalizedCostPerUnit;
    },

    isProjectUsingNormalizedCost: function(project_ref){
        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit[project_ref]){
            return false;
        }
        return true;
    },
    /**
     * This function returns all the fields that we want to return for the tree. It is built depending on the settings for cost calculations so
     * that we know to include all necessary fields.
     * @param fetch
     * @returns {*}
     */
    getTreeFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }


        return Ext.Array.merge(fetch, CArABU.technicalservices.PortfolioItemCostTrackingSettings.getStoryFetch(),
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemFetch(),
            (CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().requiredTaskFetch || []));

    },
    getStoryFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(fetch, CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredFetch,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().requiredStoryFetch);

    },
    getPortfolioItemFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredFetch,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings._getPreliminaryBudgetFields(),
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredPortfolioItemFetch);

    },
    _getPreliminaryBudgetFields: function(){
        var preliminaryBudgetFields = [CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField];
        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField === "PreliminaryEstimate"){
            preliminaryBudgetFields.push('Value');
        }
        return preliminaryBudgetFields;
    },
    getFields: function(config) {

        var current_calculation_type = (config && config.selectedCalculationType) || 'points',
            current_project_costs = (config && config.projectCostPerUnit) || {};

        var currency_store = Ext.create('Rally.data.custom.Store', {
            data: CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyData
        });
        var labelWidth = 100;

        var cost_items = [];
        _.each(CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes, function(obj, key){
            cost_items.push({
                boxLabel: obj.label || key,
                name: 'selectedCalculationType',
                inputValue: key,
                disabled: obj.disabled || false,
                checked: key === current_calculation_type
            });
        });

        return [{
            xtype: 'rallycombobox',
            name: 'currencySign',
            store: currency_store,
            displayField: 'name',
            valueField: 'value',
            fieldLabel:  'Currency',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'numberfieldcombobox',
            name: 'preliminaryBudgetField',
            fieldLabel: 'Calculate Preliminary Budget using',
            model: 'PortfolioItem',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Calculate Cost',
            columns: 1,
            vertical: true,
            labelWidth: labelWidth,
            margin: '10 0 10 0',
            items: cost_items
        },{
            xtype: 'rallytextfield',
            name: 'normalizedCostPerUnit',
            fieldLabel: 'Normalized Cost Per Unit',
            labelWidth: labelWidth,
            width: 200,
            value: config.normalizedCostPerUnit,
            margin: '25 0 0 0'
        },{
            xtype: 'costperprojectsettings',
            name: 'projectCostPerUnit',
            fieldLabel: 'Optionally define costs per unit for individual teams (exceptions to the normalized cost)',
            labelAlign: 'top',
            margin: '25 0 0 0',
            value: current_project_costs,
            readyEvent: 'ready'
        }];
    }
});
Ext.define("portfolio-cost-tracking-v2", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),

    mixins: [],

    printHeaderLabel: 'Portfolio Items',
    statePrefix: 'portfolio-tree',

    config: {
        defaultSettings: {
            piTypePickerConfig: {
                renderInGridHeader: true
            },
            selectedCalculationType: 'points',
            normalizedCostPerUnit: 1000,
            projectCostPerUnit: {},
            currencySign: '$',
            preliminaryBudgetField: 'PreliminaryEstimate'
        }
    },
    toggleState: 'grid',
    enableAddNew: false,
    enableGridBoardToggle: false,
    allowExpansionStateToBeSaved: false,
    plugins: ['rallygridboardappresizer'],
    actionMenuItems: [],
    enableImport: true,
    enableCsvExport: true,
    enablePrint: true,
    enableRanking: true,
    isWorkspaceScoped: false,
    modelNames: [],
    modelsContext: null,
    printHeaderLabel: '',
    statePrefix: null,

    items: [],

    portfolioItemRollupData: {},

    launch: function(){
        //todo: check for RPM?
        this.loadModelNames().then({
            success: function (modelNames) {
                this.modelNames = modelNames;
                if(!this.rendered) {
                    this.on('afterrender', this.loadGridBoard, this, {single: true});
                } else {
                    this.loadGridBoard();
                }
            },
            scope: this
        });
    },
    loadModelNames: function () {
        var promises = [this.fetchDoneStates(), this._createPITypePicker()];
        return Deft.Promise.all(promises).then({
            success: function (results) {
                this.currentType = results[1];
                this._initializeSettings(this.getSettings(), results[0], this.piTypePicker);
                this._initializeRollupData(this.currentType.get('TypePath'));
                return [this.currentType.get('TypePath')];
            },
            scope: this
        });
    },
    loadGridBoard: function () {
        this.logger.log('loadGridBoard', this.modelNames);
        //return Rally.data.ModelFactory.getModels({
        //    context: this.getContext(),
        //    types: this.modelNames,
        //    requester: this
        //}).then({
        //    success: function (models) {
        //        this.models = _.transform(models, function (result, value) {
        //            result.push(value);
        //        }, []);
        //
        //        this.modelNames = _.keys(models);

                return this._getTreeGridStore().then({
                    success: function (store) {
                        this.addGridBoard(store);
                    },
                    scope: this
                });
        //    },
        //    scope: this
        //});
    },

    addGridBoard: function (store) {
        if (this.gridboard) {
            this.gridboard.destroy();
        }
        var customColumns = this.getDerivedColumns() || [],
            columnCfgs = Ext.Array.merge(this.getColumnCfgs() || [], customColumns);
        this.logger.log('addGridBoard', store, this.modelNames);

        this.gridboard = this.add({
            itemId: 'gridboard',
            xtype: 'rallygridboard',
            context: this.getContext(),
            toggleState: 'grid',
            stateful: false,
            stateId: 'gridboard',
            modelNames: _.clone(this.modelNames),
            plugins: this.getGridBoardPlugins(),
            gridConfig: {
                columnCfgs: columnCfgs,
                derivedColumns: customColumns,
                store: store
            },
            height: this.getHeight()
        });
        this.gridboard.on('modeltypeschange', this._onTypeChange, this);


        this.fireEvent('gridboardadded', this.gridboard);
    },
    /**
     * We need to override this to show the picker in the grid header and also save state
     * rather than as a configuration
     */
    getGridBoardPlugins: function () {
        var plugins = [{
                ptype: 'rallygridboardinlinefiltercontrol',
                inlineFilterButtonConfig: {
                    modelNames: this.modelNames,
                    inlineFilterPanelConfig: {
                        collapsed: false,
                        quickFilterPanelConfig: {
                            fieldNames: ['Owner', 'ScheduleState']
                        }
                    }
                }
        }];

        plugins.push({
            ptype: 'rallygridboardfieldpicker',
            headerPosition: 'left',
            modelNames: this.modelNames,
            stateful: true,
            stateId: this.getContext().getScopedStateId('field-picker')
        });

        plugins = plugins.concat(this.getActionsMenuConfig() || []);
        return plugins;
    },
    getActionsMenuConfig: function () {
        var importItems = this._getImportItems();
        var printItems = this._getPrintItems();
        var exportItems = this._getExportItems();

        var tooltipTypes = []
            .concat(importItems.length ? 'Import' : [])
            .concat(exportItems.length ? 'Export' : [])
            .concat(printItems.length ? 'Print' : []);

        var menuItems = this.actionMenuItems.concat(importItems, exportItems, printItems);

        return tooltipTypes.length === 0 || this.toggleState === 'board' ? [] : [{
            ptype: 'rallygridboardactionsmenu',
            menuItems: menuItems,
            buttonConfig: {
                hidden: this.toggleState !== 'grid',
                iconCls: 'icon-export',
                toolTipConfig: {
                    html: tooltipTypes.join('/'),
                    anchor: 'top',
                    hideDelay: 0
                }
            }
        }];
    },
    _createPITypePicker: function () {
        if (this.piTypePicker && this.piTypePicker.destroy) {
            this.piTypePicker.destroy();
        }

        var deferred = new Deft.Deferred();

        var piTypePickerConfig = {
            preferenceName: this.getStateId('typepicker'),
            //stateful: true,
            //stateId: this.getContext().getScopedStateId('cb-type'),
            context: this.getContext(),
            listeners: {
                select: this._onTypeChange,
                ready: {
                    fn: function (picker) {
                        deferred.resolve(picker.getSelectedType());
                    },
                    single: true
                },
                scope: this
            }
        };

        this.piTypePicker = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', piTypePickerConfig);
        this.on('gridboardadded', function() {
            var headerContainer = this.gridboard.getHeader().getLeft();
            headerContainer.add(this.piTypePicker);
        });

        return deferred.promise;
    },
    getGridConfig: function (options) {


        var customColumns = this.getDerivedColumns() || [],
            columnCfgs = Ext.Array.merge(this.getColumnCfgs() || [], customColumns);

        var config = {
         //   xtype: 'rallytreegrid',
          //  alwaysShowDefaultColumns: false,
          //  bufferedRenderer: true,
            columnCfgs: columnCfgs,
            derivedColumns: customColumns,
        //    enableBulkEdit: true,
            //allowExpansionStateToBeSaved: this.allowExpansionStateToBeSaved,
        //    enableInlineAdd: Rally.data.ModelTypes.areArtifacts(this.modelNames),
        //    enableRanking: false,
            //enableSummaryRow: Rally.data.ModelTypes.areArtifacts(this.modelNames),
           // expandAllInColumnHeaderEnabled: true,
            //plugins: this.getGridPlugins(),
        //    stateId: this.getContext().getScopedStateId('portfolio-cost-tracking-grid'),
        //    stateful: false,
            store: options && options.gridStore,
            //storeConfig: {
            //    filters: this.getPermanentFilters()
            //}
        };


        if (this.modelNames.length === 1 && !Rally.data.ModelTypes.isArtifact(this.modelNames[0])) {
            config.noDataItemName = this.modelNames[0].toLowerCase();
        }

        this.logger.log('getGridConfig', config)
        return config;
    },
    _initializeRollupData: function(newType){
        this.logger.log('_initializeRollupData', newType);
        if (this.rollupData){
            this.rollupData.destroy();
        }

        this.rollupData = Ext.create('CArABU.technicalservices.RollupCalculator', {
            portfolioItemType: newType
        });
    },
    _initializePortfolioItemTypes: function(cb){

        var items = cb.getStore().data.items,
            portfolioItemTypes = new Array(items.length);

        Ext.Array.each(items, function(item){
            var idx = Number(item.get('Ordinal'));
            portfolioItemTypes[idx] = { typePath: item.get('TypePath'), name: item.get('Name'), ordinal: idx };
        });
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.portfolioItemTypes = portfolioItemTypes;
    },
    _onTypeChange: function (picker) {
        var newType = picker.getSelectedType();
        this.logger.log('_onTypeChange', newType);
        if (this._pickerTypeChanged(picker)) {
            this.currentType = newType;
            this.modelNames = [newType.get('TypePath')];
            this._initializeRollupData(newType.get('TypePath'));
            this.gridboard.fireEvent('modeltypeschange', this.gridboard, [newType]);
        }
    },

    _pickerTypeChanged: function(picker){
        var newType = picker.getSelectedType();
        return newType && this.currentType && newType.get('_ref') !== this.currentType.get('_ref');
    },
    _initializeSettings: function(settings, doneScheduleStates, piTypePicker){

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.notAvailableText = "--";
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencySign = settings.currencySign;
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyPrecision = 0;
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyEnd = false;
        if (doneScheduleStates){
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.completedScheduleStates = doneScheduleStates;
        }
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.normalizedCostPerUnit = settings.normalizedCostPerUnit;

        var project_cpu = settings.projectCostPerUnit || {};
        if (!Ext.isObject(project_cpu)){
            project_cpu = Ext.JSON.decode(project_cpu);
        }
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit = project_cpu;

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField = settings.preliminaryBudgetField;

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.setCalculationType(settings.selectedCalculationType);

        this._initializePortfolioItemTypes(piTypePicker);

    },
    _showExportMenu: function () {
        var columnCfgs = this.down('rallytreegrid').columnCfgs,
            additionalFields = _.filter(columnCfgs, function(c){ return (c.xtype === 'rallyfieldcolumn'); }),
            costFields = this.getDerivedColumns(),
            columns = Ext.Array.merge(additionalFields, costFields);

        additionalFields = _.pluck(additionalFields, 'dataIndex');

        var filters = this.down('rallygridboard').currentCustomFilter.filters || [],
            fetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getTreeFetch(additionalFields),
            root_model = this.currentType.get('TypePath');

        var exporter = new CArABU.technicalservices.Exporter();
        exporter.on('statusupdate', this._showStatus, this);

        exporter.fetchExportData(root_model,filters,fetch,columns).then({
            scope: this,
            success: function(csv){
                var filename = Ext.String.format("export-{0}.csv",Ext.Date.format(new Date(),"Y-m-d-h-i-s"));
                exporter.saveCSVToFile(csv, filename);
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: "An error occurred fetching the data to export:  " + msg});
            }
        });
    },
    _loadRollupData: function(records){

        var loader = Ext.create('CArABU.technicalservices.RollupDataLoader',{
            context: this.getContext(),
            portfolioItemTypes: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(),
            featureName: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName(),
            listeners: {
                rollupdataloaded: function(portfolioHash, stories){
                    this._processRollupData(portfolioHash,stories,records);
                },
                loaderror: this._handleLoadError,
                statusupdate: this._showStatus,
                scope: this
            }
        });
        loader.loadDescendants(records);
    },
    _handleLoadError: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    _processRollupData: function(portfolioHash, stories, records){
        var me = this;
        portfolioHash[records[0].get('_type').toLowerCase()] = records;
        this.rollupData.addRollupRecords(portfolioHash, stories);
        this.rollupData.updateModels(records);

        me._showStatus(null);
    },
    _showStatus: function(message){
        if (message) {
            Rally.ui.notify.Notifier.showStatus({
                message: message,
                showForever: true,
                closable: false,
                animateShowHide: false
            });
        } else {
            Rally.ui.notify.Notifier.hide();
        }
    },
    _getExportItems: function() {
        return [{
            text: 'Export to CSV...',
            handler: this._showExportMenu,
            scope: this
        }];
    },
    _getImportItems: function(){
        return [];
    },
    _getPrintItems: function(){
        return [];
    },
    _getTreeGridStore: function () {

        var fetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getTreeFetch([]);
        this.logger.log('_getTreeGridStore', fetch)
        return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            autoLoad: true,
            childPageSizeEnabled: true,
            context: this.getContext().getDataContext(),
            enableHierarchy: true,
            fetch: fetch,
            models: this.modelNames, // _.clone(this.models),
            pageSize: 25,
            remoteSort: true,
            root: {expanded: true}
        }).then({
            success: function (treeGridStore) {
                treeGridStore.model.addField({name: '_rollupData', type: 'auto', defaultValue: null});
                treeGridStore.on('load', this._fireTreeGridReady, this, { single: true });
                treeGridStore.on('load', this.updateDerivedColumns, this);
                return treeGridStore;
            },
            scope: this
        });
    },
    updateDerivedColumns: function(store, node, records){
        if (!store.model.getField('_rollupData')){
            store.model.addField({name: '_rollupData', type: 'auto', defaultValue: null});
        }

        var unloadedRecords = this.rollupData.updateModels(records);

        if (unloadedRecords && unloadedRecords.length > 0 && node.parentNode === null){
            this._loadRollupData(unloadedRecords);
        }
    },
    getDerivedColumns: function(){

        return [{
            text: "Actual Cost To Date",
            xtype: 'costtemplatecolumn', //'actualcosttemplatecolumn',
            dataIndex: '_rollupData',
            costField: '_rollupDataActualCost',
            sortable: false,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataActualCost')
        },{
            text: "Remaining Cost",
            xtype: 'costtemplatecolumn', //'remainingcosttemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataRemainingCost',
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataRemainingCost')
        }, {
            text: 'Total Projected',
            xtype: 'costtemplatecolumn', //'totalcosttemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataTotalCost',
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataTotalCost')
        },{
            text: 'Preliminary Budget',
            xtype: 'costtemplatecolumn', //'preliminarybudgettemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataPreliminaryBudget',
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataPreliminaryBudget')
        }];
    },
    getColumnCfgs: function(){

        return  [{
            dataIndex: 'Name',
            text: 'Name',
            flex: 5
        },{
            dataIndex: 'Project',
            text: 'Project',
            editor: false
        },{
            dataIndex: 'LeafStoryPlanEstimateTotal',
            text: 'Plan Estimate Total'
        }, {
            dataIndex: 'PercentDoneByStoryPlanEstimate',
            text: '% Done by Story Points'
        }];
    },
    getSettingsFields: function() {
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFields(this.getSettings());
    },
    onSettingsUpdate: function(settings){

        this._initializeSettings(settings,null,this.piTypePicker);
        this._initializeRollupData(this.currentType.get('TypePath'));
        this.loadGridBoard();
    },
    onDestroy: function() {
        this.callParent(arguments);
        if (this.rollupData){
            delete this.rollupData;
        }
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {

                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') === "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});

            
               Rally.launchApp('portfolio-cost-tracking-v2', {
                   name: 'Portfolio Cost Tracking (v2)'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.lbl {

    text-transform: uppercase;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 10px;
}

.x-form-trigger-wrap {
    margin-top: 0px!important;
}

.x-column-header-text {
    margin-right: 0px!important;
}
.x-box-inner {
    overflow: visible;
}

p {
    color:#FAD200;
}
    </style>

</head>
<body></body>
</html>